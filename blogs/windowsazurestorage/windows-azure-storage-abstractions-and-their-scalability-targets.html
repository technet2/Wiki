---
layout: windowsazurestorage
title: Windows Azure Storage Abstractions and their Scalability Targets
weight: 3
---

<div id="site-content" class="site-content row">

	<div id="primary" class="content-area col-sm-9">
		<div id="single-content" class="div-content">

			
				
<article id="post-24" class="post-24 post type-post status-publish format-standard hentry category-uncategorized tag-scalability">

	<header class="entry-header single">
		<h1 class="entry-title">Windows Azure Storage Abstractions and their Scalability Targets</h1>		<div class="rating-wrap">
		<div id="star-rating-24" class="wds-ratings" data-rating="5" data-userrating="0" data-postid="24" data-container="body" data-toggle="tooltip" title="4 user(s) rated">
			<div class="wds-ratings-inner-wrap">
				<div>
					<div aria-label="Select 5 star, this article is 5 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="5"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span><span aria-hidden="true" class="star-5"><span>&#x2605;</span></span></div><div aria-label="Select 4 star, this article is 5 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="4"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span></div><div aria-label="Select 3 star, this article is 5 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="3"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span></div><div aria-label="Select 2 star, this article is 5 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="2"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span></div><div aria-label="Select 1 star, this article is 5 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="1"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span></div>
				</div>
			</div>
		</div>
		</div>		<div class="clear-both"></div>
		<div class="entry-meta">
			<img alt="avatar of windows-azure-storage" src="https://i1.social.s-msft.com/profile/u/avatar.jpg?displayname=Windows+Azure+Storage&amp;size=extralarge&amp;version=00000000-0000-0000-0000-000000000000" class="avatar avatar-22 photo" height="22" width="22"/><span class="byline"><span class="author vcard"><a class="url fn n profile-usercard-hover" data-profile-userid="59e1aedafa2d4428b7004b2c2fac4adc" href="https://social.msdn.microsoft.com/profile/Windows+Azure+Storage">Windows Azure Storage</a></span></span><span class="posted-on posted-on-margin"><span class="screen-reader-text"></span><time class="entry-date published updated" datetime="2010-05-10T14:41:00+00:00">May 10, 2010</time></span><span class="comments-link"><span class="glyphicon glyphicon-comment" aria-hidden="true"></span><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comments">10</a></span>				<span class="social-icons-wrap">
		<ul class="social-icons">
			<li><div class="fb-share-button" data-href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/" data-layout="button_count" data-size="large" data-mobile-iframe="true"><a class="fb-xfbml-parse-ignore" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/&amp;src=sdkpreparse">Share</a></div></li>
			<div id="fb-root" style="display:none"></div>

			<li class="social-icon twitter"><a data-social="{&quot;type&quot;:&quot;twitter&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/&quot;, &quot;text&quot;: &quot;Windows Azure Storage Abstractions and their Scalability Targets&quot;}" href="#" id="post_tweet_count">0</a></li>
			<li class="social-icon linkedin"><a data-social="{&quot;type&quot;:&quot;linkedin&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/&quot;, &quot;text&quot;: &quot;Windows Azure Storage Abstractions and their Scalability Targets&quot;}" href="#" id="get_post_linkedin_count">0</a></li>
		</ul>
	</span><!-- .social-icons-wrap -->
	<script type="text/javascript">
		// Get social counts
		jQuery( window ).load(function () {
			jQuery.getScript('https://blogs.msdn.microsoft.com/windowsazurestorage/wp-content/themes/microsoft/js/social-counts.js?ver=02092017')
				.done(function(script,textStatus) {
					window.msdnsocial.ajax('https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/');
				});
		});
	</script>
		</div>
		<hr>
	</header><!-- .entry-header -->

	<div class="entry-content single">
		<p>The four object abstractions Windows Azure Storage provides for application developers are:</p>
<ul>
<li><b>Blobs</b> &ndash; Provides a simple interface for storing named files along with metadata for the file. </li>
<li><b>Tables </b>&ndash; Provides massively scalable structured storage. A Table is a set of entities, which contain a set of properties. An application can manipulate the entities and query over any of the properties stored in a Table. </li>
<li><b>Queues</b> &ndash; Provide reliable storage and delivery of messages for an application to build loosely coupled and scalable workflow between the different parts (roles) of your application. </li>
<li><b>Drives</b> &ndash; Provides durable NTFS volumes for Windows Azure applications to use. This allows applications to use existing NTFS APIs to access a network attached durable drive. Each drive is a network attached Page Blob formatted as a single volume NTFS VHD. In this post, we do not focus on drives, since their scalability is that of a single blob. </li>
</ul>
<p>The following shows the Windows Azure Storage abstractions and the Uris used for Blobs, Tables and Queues. In this post we will (a) go through each of these concepts, (b) describe how they are partitioned (c) and then talk about the scalability targets for these storage abstractions.</p>
<p><a href="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_2.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_2.png"><img height="422" width="522" src="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb.png" alt="image" border="0" title="image" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px"/></a> </p>
<p><b></b></p>
<h4>Storage Accounts and Picking their Locations</h4>
<p>In order to access any of the storage abstractions you first need to create a storage account by going to the <a href="http://www.microsoft.com/windowsazure/account/">Windows Azure Developer Portal</a>. When creating the storage account you can specify what location to place your storage account in. The six locations we currently offer are:</p>
<ol>
<li>US North Central </li>
<li>US South Central </li>
<li>Europe North </li>
<li>Europe West </li>
<li>Asia East </li>
<li>Asia Southeast </li>
</ol>
<p>As a best practice, you should choose the same location for your storage account and your hosted services, which you can also do in the Developer Portal. This allows the computation to have high bandwidth and low latency to storage, and the bandwidth is free between computation and storage in the same location.</p>
<p>Then also shown in the above slide is the Uri used to access each data object, which is:</p>
<ul>
<li>Blobs
<ul>
<li><a href="http://accountname.blob.core.windows.net/<containerName>/<blobName">/http://accountName.blob.core.windows.net/&lt;containerName&gt;/&lt;blobName</a>&gt; </li>
</ul>
</li>
<li>Tables
<ul>
<li><a href="http://accountname.table.core.windows.net/<TableName">http://accountName.table.core.windows.net/&lt;TableName</a>&gt; </li>
</ul>
</li>
<li>Queues
<ul>
<li><a href="http://accountname.queue.core.windows.net/<QueueName">http://accountName.queue.core.windows.net/&lt;QueueName</a>&gt; </li>
</ul>
</li>
</ul>
<p>The first thing to notice is that the storage account name you registered in the Developer Portal is the first part of the hostname. This is used via DNS to direct your request to the location that holds all of the storage data for that storage account. Therefore, all of the requests to that storage account (inserts, updates, deletes, and gets) go to that location to access your data. Finally, notice in the above hostnames the keyword &ldquo;blob&rdquo;, &ldquo;table&rdquo; and &ldquo;queue&rdquo;. This directs your request to the appropriate Blob, Table and Queue service in that location. Note, since the Blob, Table and Queue are separate services, they each have their own namespace under the storage account. This means in the same storage account you can have a Blob Container, Table and Queue each called &ldquo;music&rdquo;.</p>
<p>Now that you have a storage account, you can store all of your blobs, entities and messages in that storage account. A storage account can hold up to 100TBs of data in it. There is no other storage capacity limit for a storage account. In particular, there is no limit on the number of Blob Containers, Blobs, Tables, Entities, Queues or Messages that can be stored in the account, other than they must all add up to be under 100TBs.</p>
<h4>Windows Azure Blobs</h4>
<p>The figure below depicts the storage concepts of Windows Azure Blob, where we have a storage account called &ldquo;cohowinery&rdquo; and inside of this account we created a Blob Container called &ldquo;images&rdquo; and put two pictures in that blob container called &ldquo;pic01.jpg&rdquo; and &ldquo;pic02.jpg&rdquo;. We also created a second blob container called &ldquo;videos&rdquo; and stored a blob called &ldquo;vid1.avi&rdquo; there.</p>
<p><a href="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_4.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_4.png"><img height="427" width="536" src="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb_1.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb_1.png" alt="image" border="0" title="image" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px"/></a> </p>
<ul>
<li><b>Storage Account </b>&ndash; All access to Windows Azure Storage is done through a storage account.
<ul>
<li>This is the highest level of the namespace for accessing blobs </li>
<li>An account can have many Blob Containers </li>
</ul>
</li>
<li><b>Blob Container</b> &ndash; A container provides a grouping of a set of blobs. The container name is scoped by the account.
<ul>
<li>Sharing policies are set at the container level, where a container can be set to private or to be publically accessible. When a container is set to Public, all its contents can be read by anyone without requiring authentication. When a container is Private, authentication is required to access the blobs in that container. </li>
<li>Containers can also have metadata associated with them. Metadata is in the form of &lt;name, value&gt; pairs, and they are up to 8KB in size per container. </li>
<li>The ability to list all of the blobs within the container is also provided. </li>
</ul>
</li>
<li><b>Blob</b> &ndash; Blobs are stored in and scoped by Blob Containers. Blobs can have metadata associated with them, which are &lt;name, value&gt; pairs, and they are up to 8KB in size per blob. The blob metadata can be set and retrieved separately from the blob data bits. </li>
</ul>
<p>The above namespace is used to perform all access to Windows Azure Blobs. The URI for a specific blob is structured as follows: </p>
<p>http://&lt;account&gt;.<b>blob</b>.core.windows.net/&lt;container&gt;/&lt;blobname&gt;</p>
<p>The storage account name is specified as the first part of the hostname followed by the keyword &ldquo;blob&rdquo;. This sends the request to the part of Windows Azure Storage that handles blob requests. The host name is followed by the container name, followed by &ldquo;/&rdquo;, and then the blob name. Accounts and <a href="http://msdn.microsoft.com/en-us/library/dd135715.aspx">containers</a> have naming restrictions, for example, the container name cannot contain a &ldquo;/&rdquo;.</p>
<p>There are two types of blobs supported:</p>
<ul>
<li><a href="http://microsoftpdc.com/Sessions/SVC14">Block Blobs</a> &ndash; targeted at streaming workloads.&nbsp;
<ul>
<li>Each blob consists of a sequence/list of blocks. </li>
<li>Max block blob size is 200GB </li>
<li>Commit-based Update Semantics &ndash; Modifying a block blob is a two-phase update process.&nbsp;&nbsp; It first consists of uploading blocks as uncommitted blocks for a blob.&nbsp; Then after they are all uploaded, the blocks to add/change/remove are committed via a <a href="http://msdn.microsoft.com/en-us/library/dd179467.aspx">PutBlockList</a> to create the updated blob.&nbsp;&nbsp; Therefore, updating a block blob is a two-phase update process where you upload all changes, and then commit them atomically. </li>
<li>Range reads can be from any byte offset in the blob. </li>
</ul>
</li>
<li><a href="http://blogs.msdn.com/windowsazurestorage/archive/2010/04/11/using-windows-azure-page-blobs-and-how-to-efficiently-upload-and-download-page-blobs.aspx">Page Blobs</a> &ndash; targeted at random write workloads.&nbsp;
<ul>
<li>Each blob consists of an array/index of pages. </li>
<li>Max page blob size is 1TB </li>
<li>Immediate Update Semantics &ndash; As soon as a write request for a sequential set of pages succeeds in the blob service, the write has committed, and success is returned back to the client.&nbsp; The update is immediate, so there is no commit step as there is for block blobs. </li>
<li>Range reads can be done from any byte offset in the blob. </li>
</ul>
</li>
</ul>
<h4>Windows Azure Tables</h4>
<p>The figure below depicts the storage concepts for Windows Azure Tables, where we have a storage account called &ldquo;cohowinery&rdquo; and inside of this account we created a Table called &ldquo;customers&rdquo; and put entities representing customers into that table, where the entities have properties like their &ldquo;name&rdquo;, &ldquo;email&rdquo;, etc. We also created a table called &ldquo;winephotos&rdquo; and the entities stored in that table contain properties of &ldquo;PhotoID&rdquo;, &ldquo;Date&rdquo;, etc.</p>
<p><a href="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_10.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_10.png"><img height="419" width="539" src="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb_4.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb_4.png" alt="image" border="0" title="image" style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px"/></a> </p>
<p>The following summarizes the data model for Windows Azure Table:</p>
<ul>
<li><b>Storage Account </b>&ndash; All access to Windows Azure Storage is done through a storage account.
<ul>
<li>This is the highest level of the namespace for accessing tables </li>
<li>An account can have many Tables </li>
</ul>
</li>
<li><b>Table</b> &ndash; contains a set of entities. Table names are scoped by the account. An application may create many tables within a storage account. </li>
<li><b>Entity (Row) </b>&ndash; Entities (an entity is analogous to a "row") are the basic data items stored in a table. An entity contains a set of properties. Each table has two properties, &ldquo;PartitionKey and RowKey&rdquo;, which form the unique key for the entity.
<ul>
<li>An entity can hold up to 255 properties </li>
<li>Combined size of all of the properties in an entity cannot exceed 1MB. This size includes the size of the property names as well as the size of the property values or their types. </li>
</ul>
</li>
<li><b>Property (Column)</b> &ndash; This represents a single value in an entity. Property names are case sensitive. </li>
<li><b>PartitionKey </b>&ndash; The first key property of every table. The system uses this key to automatically distribute and load balance the table&rsquo;s entities over many servers. </li>
<li><b>RowKey </b>&ndash; A second key property for the table. This is the unique ID of the entity within the partition it belongs to. The PartitionKey combined with the RowKey uniquely identifies an entity in a table. </li>
<li><b>Timestamp </b>&ndash; Every entity has a version maintained by the system. This is used for optimistic concurrency. </li>
<li><b>Sort Order </b>&ndash; There is a single index for Windows Azure Tables, where all entities in a table are sorted by PartitionKey and then RowKey. This means that queries specifying these keys will be more efficient, and all results are returned sorted by PartitionKey and then by RowKey. </li>
<li><b>Types</b> &ndash; PartitionKey and RowKey must be of type string and the rest of the properties can be any of the following types: Binary, Bool, DateTime, Double, GUID, Int, Int64, String. </li>
<li><b>No Fixed Schema</b> &ndash; No schema is stored by Windows Azure Table, so all of the properties are stored as &lt;name, typed value&gt; pairs. This means that two entities in the same table can have very different properties. A table can even have two entities with the same property name, but different types for the property value. However, property names must be unique within a single entity. </li>
</ul>
<p>The above namespace is used to perform all access to Windows Azure Table. The URI for a specific table access is structured as follows: </p>
<p>http://&lt;account&gt;.<b>table</b>.core.windows.net/&lt;TableName&gt;</p>
<p>The storage account name is specified as the first part of the hostname followed by the keyword &ldquo;table&rdquo;. This sends the request to the part of Windows Azure Storage that handles table requests. The host name is followed by the table name, and then the rest of the Uri will specify what entity is being operated on or the query string to be looked up.</p>
<h4><b>Windows Azure Queues</b></h4>
<p>The figure below depicts the storage concepts of Windows Azure Queues, where we have a storage account called &ldquo;cohowinery&rdquo; and inside of this account we created a Queue called &ldquo;orders&rdquo;, which stores the orders in messages that are waiting to be processed. The messages in the example contain the customer ID, order ID, a link to order details, etc.</p>
<p><a href="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_8.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_8.png"><img height="421" width="534" src="https://msdnshared.blob.core.windows.net/media/TNBlogsFS/BlogFileStorage/blogs_msdn/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb_3.png" original-url="http://blogs.msdn.com/blogfiles/windowsazurestorage/WindowsLiveWriter/WindowsAzureStorageAbstractionsandtheirS_13104/image_thumb_3.png" alt="image" border="0" title="image" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px"/></a> </p>
<ul>
<li><b>Storage Account </b>&ndash; All access to Windows Azure Storage is done through a storage account.
<ul>
<li>This is the highest level of the namespace for accessing queues </li>
<li>An account can have many Queues </li>
</ul>
</li>
<li><b>Queue</b> &ndash; A queue contains many messages. The queue name is scoped by the account.
<ul>
<li>There is no limit on the number of messages stored in a queue (the only limit is the 100TB size limit on the storage account). </li>
<li>A message is stored for at most a week. The system will garbage collect the messages that are more than a week old. </li>
<li>Queues can have metadata associated with them. Metadata is in the form of &lt;name, value&gt; pairs, and they are up to 8KB in size per queue. </li>
</ul>
</li>
<li><b>Messages</b> &ndash; Messages are stored in queues. Each message can be up to 8KB in size. To store larger data, one can store the data in Azure Blob store or Azure Table store, and then store the blob/entity name in the message. Note that when you put a message into the store, the message data can be binary. But when you get the messages back from the store, the response is in XML format, and the message data is returned as base64 encoded. </li>
</ul>
<p>The URI for a specific queue is structured as follows: </p>
<p>http://&lt;account&gt;.<b>queue</b>.core.windows.net/&lt;QueueName&gt;</p>
<p>The storage account name is specified as the first part of the hostname followed by the keyword &ldquo;queue&rdquo;. This sends the request to the part of Windows Azure Storage that handles queue requests. The host name is followed by the queue name.</p>
<h4>Partitions</h4>
<p>A very important concept to understand about the storage abstractions is their partitioning. Every data object (Blobs, Table Entities and Queue Messages) has a partition key. This is how we locate the objects in our service when accessing them, and how we load balance and partition the objects across our servers to meet the traffic needs of those objects. The following is the partition key used for our three storage abstractions:</p>
<ul>
<li>Blobs &ndash; ContainerName + BlobName </li>
<li>Entities &ndash; TableName + PartitionKey </li>
<li>Messages - QueueName </li>
</ul>
<p>Our system automatically load balances these objects across our servers based upon these partitions. All objects with the same partition key value are grouped into the same partition and are accessed from the same partition server (<i>see the upcoming post on Windows Azure Storage Architecture Overview</i>). Grouping objects into partitions allow us to (a) easily perform atomic operations across objects in the same partition since their access goes to the same server, and (b) have caching locality of objects within the same partition to benefit from data access locality.</p>
<p>So what does this mean for Blobs, Entities and Messages with the above partition keys? </p>
<ul>
<li><b>Blobs</b> &ndash; Since the partition key is down to the blob name, we can load balance access to different blobs across as many servers in order to scale out access to them. This allows the containers to grow as large as you need them to (within the storage account space limit). The tradeoff is that we don&rsquo;t provide the ability to do atomic transactions across multiple blobs. </li>
<li><b>Entities</b> &ndash; Every Table has an application defined PartitionKey used by each entity. This means we can load balance the entities within a table across different servers at PartitionKey boundaries (meaning entities with different PartitionKey values). Then for the entities within the same partition (they have the same PartitionKey value) we allow applications to perform atomic batch transactions over them, since they are served from the same server. </li>
<li><b>Messages</b> &ndash; Since the partition key is the queue name, all messages to a given queue are processed by a single partition server, but different queues can be processed by different servers to spread out the load to the different queues a storage account may have. </li>
</ul>
<h4>Scalability and Performance Targets</h4>
<p>Now that we have given a high level description of storage accounts, storage abstractions and how they are grouped into partitions, we want to talk about the scalability targets for storage accounts, objects and their partitions.</p>
<p><b>The following are the scalability targets for a single storage account:</b></p>
<ul>
<li><b>Capacity</b> &ndash; Up to 100 TBs </li>
<li><b>Transactions</b> &ndash; Up to&nbsp;5,000&nbsp;entities/messages/blobs per second </li>
<li><b>Bandwidth</b> &ndash; Up to 3 gigabits per second </li>
</ul>
<p>The 100TB is a strict limit for a storage account, whereas the transactions and bandwidth are the current targets we&rsquo;ve built the system to for a single storage account. Note, the actual transaction and bandwidth achieved by your storage account will very much depend upon the size of objects, access patterns, and the type of workload your application exhibits. To go above these targets, a service should be built to use multiple storage accounts, and partition the blob containers, tables and queues and objects across those storage accounts.&nbsp; By default, a subscription gets 5 storage accounts, and you can contact <a href="https://support.microsoft.com/oas/default.aspx?prid=13185&amp;st=1">customer support</a> to get more storage accounts if you need to store more than that (e.g., petabytes) of data.&nbsp;&nbsp; </p>
<p>It is expected that a hosted service needs up to as many storage accounts to meet its performance targets given the above, which is typically a handful of storage accounts to up to 10s of storage accounts to store PBs of data.&nbsp;&nbsp; The point here is that a hosted service should not plan on creating a separate storage account for each of its customers.&nbsp; Instead, the hosted service should either represent a customer within a storage account (e.g., each customer could have its own Blob Container), or map/hash the customer&rsquo;s data across the hosted service&rsquo;s storage accounts.</p>
<p>Within a storage account, all of the objects are grouped into partitions as described above. Therefore, it is important to understand the performance targets of a single partition for our storage abstractions, which are:</p>
<ul>
<li><b>Single Queue</b> &ndash; all of the messages in a queue are accessed via a single queue partition. A single queue is targeted to be able to process:
<ul>
<li>Up to 500&nbsp;messages&nbsp;per second </li>
</ul>
</li>
<li><b>Single Table Partition</b> &ndash; a table partition are all of the entities in a table with the same partition key value, and most tables have many partitions. The throughput target for a single partition is:
<ul>
<li>Up to 500&nbsp;entities per second </li>
<li>Note, this is for a single partition, and not a single table. Therefore, a table with good partitioning, can process up to a few thousand requests per second (up to the storage account target). </li>
</ul>
</li>
<li><b>Single Blob</b> &ndash; the partition key for blobs is the &ldquo;container name + blob name&rdquo;, so we can partition blobs down to a single blob to spread out blob access across our servers. The target throughput of a single blob is:
<ul>
<li>Up to 60 MBytes/sec </li>
</ul>
</li>
</ul>
<p>The above throughputs are the high end targets for the current system. What can be achieved by your application very much depends upon the size of the objects being accessed, the operations (workload) and the access patterns. We encourage all services to test the performance at the partition level for their workload.</p>
<p>When your application reaches the limit to what a partition can handle for your workload, it will start to get back &ldquo;503 server busy&rdquo; responses. When this occurs, the application should use exponential backoff fo<a name="_GoBack" title="_GoBack"></a>r retries. The exponential backoff allows the load on the partition to decrease, and to ease out spikes in traffic to the partition. If this is a regular occurrence, then the application should try to improve its data partitioning and throughput as follows for the different storage abstractions:</p>
<ul>
<li><b>Blobs </b>&ndash; consider using <a href="http://social.msdn.microsoft.com/Forums/en-US/windowsazure/thread/d804c832-d06e-4171-99dc-8c7020b7ec15/">Windows Azure Content Delivery Network</a> for delivering anonymous access to hot blobs to achieve higher throughput for commonly accessed blobs. </li>
<li><b>Tables </b>&ndash; use a more finely grained PartitionKey for the table in order to allow us to automatically spread the table partitions across more servers. </li>
<li><b>Queues</b> &ndash; batch together multiple work items into a single message to improve queue throughput or use multiple queues. </li>
</ul>
<p><i>See the next set of upcoming posts on best practices for scaling the performance of Blobs, Tables and Queues.</i></p>
<p>Finally, one question we get is what the expected latency is for accessing small objects:</p>
<ul>
<li>The latency is typically around 100ms when accessing small objects (less than 10s of KB) from Windows Azure hosted services that are located in the same location (sub-region) as the storage account. </li>
<li>Once in awhile the latency can increase to a few seconds during heavy spikes while automatic load balancing kicks in (<i>see the upcoming post on Windows Azure Storage Architecture and Availability</i>). </li>
</ul>
<p>Brad Calder</p>
	</div><!-- .entry-content -->


	<footer class="entry-footer single">
					<div class="tags">
				<span>Tags </span>
				<span>
					<a href="https://blogs.msdn.microsoft.com/windowsazurestorage/tag/scalability/" rel="tag">Scalability</a>				</span>
			</div>
				<hr>
	</footer><!-- .entry-footer -->

</article><!-- #post-## -->

			
		</div><!-- #single-content -->

		
<div id="comments" class="comments-area">
	<div class="comments-title">
		Comments (10)	</div>

		<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title"> <small><a rel="nofollow" id="cancel-comment-reply-link" href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#respond" style="display:none;">Cancel reply</a></small></h3><p class="must-log-in">You must be <a href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">logged in</a> to post a comment.</p>	</div><!-- #respond -->
	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-32">
				<div id="div-comment-32" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/e1bccf2f7dd58eb925e2cbbec394d150?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/e1bccf2f7dd58eb925e2cbbec394d150?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Joannes Vermorel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-32">
			May 11, 2010 at 2:07 am</a>		</div>

		<p>500 transactions per second for the queue is really really low. Classical non-cloud systems are doing much better without even distributing the distributing the load (just a mirror for continuous backup).</p>
<p>I would expect at least 100x better scalability. Basically, Twitter should be able to run their short messages on Azure Queues. The situation is even more frustrating because increasing queue throughput through queue sharding is not *that* hard actually (and could be done on the cloud side actually).</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-33">
				<div id="div-comment-33" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/a79a1b675acd535552dd5817613979ab?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a79a1b675acd535552dd5817613979ab?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">shop.calder@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-33">
			May 14, 2010 at 10:29 pm</a>		</div>

		<p>@Joannes</p>
<p>Yes, that is a good point. &nbsp; What we recommend is that customers represent multiple work items per message or to use multiple queues to get higher throughput out of queues. &nbsp; Note, we have architected the system to support higher throughputs for queues over time, and we need to see where exposing that rates in terms of customer priorities. &nbsp; Please rate the importance here relative to the other ideas: &nbsp;<a rel="nofollow" target="_new" href="http://www.mygreatwindowsazureidea.com/forums/34192-windows-azure-feature-voting">http://www.mygreatwindowsazureidea.com/forums/34192-windows-azure-feature-voting</a></p>
<p>Thanks again for the feedback.</p>
<p>Brad</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-43">
				<div id="div-comment-43" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Joe</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-43">
			August 10, 2010 at 11:10 pm</a>		</div>

		<p>For the transaction and bandwidth account scalability targets, as well as the latency during load balancing, can you quantify &quot;a few&quot;? &nbsp;Some people define it as 2-3, others say 3-5, etc.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-48">
				<div id="div-comment-48" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Jonathan</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-48">
			August 27, 2010 at 4:30 am</a>		</div>

		<p>Great post, very informative.</p>
<p>One comment. &nbsp;The article talks a lot about upper limits on performance&#8211;up to 500 transactions per second, up to 60MB/sec, etc.</p>
<p>I&#39;d be much more interested in lower limits&#8211;that&#39;s what has a business impact on my application.</p>
<p>I understand there are edge cases where delays can kick in, but these could easily be avoided e.g. by using percentiles.</p>
<p>I also understand that these figures might not form part of a binding SLA (but it would be great if they did). &nbsp;Even so, would it be possible to publish some target figures, or measured statistics?</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-54">
				<div id="div-comment-54" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Zach Parrish</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-54">
			November 3, 2010 at 9:42 am</a>		</div>

		<p>For Table Storage, you say the throughput target for a single partition is up to 500 transactions per second. How do entity group transactions fit into that? I know for billing purposes an entity group transaction only counts once, but is that true for throughput as well, or will 100 entities in a single entity group transaction contribute 100 transactions towards the throughput target?</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-55">
				<div id="div-comment-55" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/a79a1b675acd535552dd5817613979ab?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a79a1b675acd535552dd5817613979ab?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">shop.calder@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-55">
			November 4, 2010 at 10:58 am</a>		</div>

		<p>@Joe</p>
<p>&#8211; For transactions it is around 5,000 transactions per second for a single storage account.</p>
<p>&#8211; For bandwidth it is around 3 Gigabits per second for a single storage account.</p>
<p>&#8211; In terms of load balancing a partition, if I understood your question correctly, it is on the order of 10-15 seconds.</p>
<p>@Jonathan</p>
<p>It really depends upon the application, its access patterns, size of transactions, mix of transactions, etc. &nbsp; Our goal is to provide the scalability targets listed for as many workloads as possible, but applications need to benchmark their performance to understand what is it is. &nbsp;In general, applications should be able to achieve these scalability targets and consistently see those targets if they following the partitioning best practices weâ€™ve gone over in the PDC talks, this blog, and technical papers.</p>
<p>@Zach</p>
<p>Sorry, should have made explained this better. &nbsp;</p>
<p>The 500 transactions per second equates to: </p>
<p>&#8211; 500 entities per second for a single Table partition. &nbsp;So if you are doing batch requests with 100 entities per batch request, then that equates to being able to do 5 batch requests per second with 100 entities in each batch request to a single Table partition.</p>
<p>&#8211; 500 messages per second for a single Queue</p>
<p>Thanks</p>
<p>Brad</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-93">
				<div id="div-comment-93" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Sergey Koloskov</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-93">
			May 10, 2011 at 2:32 pm</a>		</div>

		<p>Check some code here:</p>
<p><a target="_new" rel="nofollow" href="http://partitioncloudqueue.codeplex.com/">partitioncloudqueue.codeplex.com</a> </p>
<p>for how to scale past 500 messages per second&nbsp;for a single Azure Queue</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-codingoutloudgmail-com odd alt thread-odd thread-alt depth-1" id="comment-282">
				<div id="div-comment-282" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://i1.social.s-msft.com/profile/u/avatar.jpg?displayname=codingoutloud&amp;size=extralarge&amp;version=6cec5dec-88fa-4e1c-822d-7e6ed9a1a89e" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn"><a href="https://social.msdn.microsoft.com/profile/codingoutloud" rel="external nofollow" class="url">codingoutloud</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-282">
			June 11, 2013 at 1:36 pm</a>		</div>

		<p>If the post on this page is of interest, this more recent post with more current information for newer storage accounts may also be of interest: <a rel="nofollow" target="_new" href="http://blogs.msdn.com/b/windowsazure/archive/2012/11/02/windows-azure-s-flat-network-storage-and-2012-scalability-targets.aspx">blogs.msdn.com/&#8230;/windows-azure-s-flat-network-storage-and-2012-scalability-targets.aspx</a></p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-783">
				<div id="div-comment-783" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Aditya</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-783">
			February 26, 2015 at 10:40 am</a>		</div>

		<p>Taking an hypothetical scenario, if i have 2 tables completely in a single partition.</p>
<p>Then if i understand correctly each table gets 500 entities per second scalability (which includes ADD/GET/UPDATE of entities) ?</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-843">
				<div id="div-comment-843" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/c1df91e4121b265140d75568e2740e04?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/c1df91e4121b265140d75568e2740e04?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Jason Hogg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/10/windows-azure-storage-abstractions-and-their-scalability-targets/#comment-843">
			March 16, 2015 at 12:49 pm</a>		</div>

		<p>Aditya, you can&#39;t have two tables in a single partition. Each entities&#39; partition key is the Table Name + Partition Key </p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F10%2Fwindows-azure-storage-abstractions-and-their-scalability-targets%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
	
</div><!-- .comments-area -->
	</div><!-- #primary -->